// new Handler programming model stuff all goes in here

interface PathExpression {
  readonly expression: string
}

interface RugCoordinate {
  group: string
  artifact: string
  version?: string
  name: string
}

interface Rug {
  readonly name: string | RugCoordinate
  readonly params: {}
  readonly type: "executor" | "generator" | "editor"
}

abstract class Executor implements Rug {
  abstract name: string
  abstract params: {}
  type: "executor"
}

abstract class Generator implements Rug {
  abstract name: string
  abstract params: {}
  type: "generator"
}

abstract class Editor implements Rug {
  abstract name: string
  abstract params: Object
  type: "editor"
}


interface TreeNode {

}

interface Event<R extends TreeNode> {
  child(): R
}

interface Handler {
  readonly name: string
  readonly description: string
  readonly expression: string | PathExpression
  readonly tags?: string[]
  handle(root: Event<TreeNode>): ExecutionPlan
}

class ExecutionPlan {
   private messages: Message[] = [];
  //  private rugs: Rug[]

   public addMessage(message: Message) {
     this.messages.push(message)
     return this;
   }

  //TODO - we should add this back in when we want to invoke rugs directly without the bot
  //  public addExecutor(rug: Executor) {
  //    this.rugs.push(rug)
  //    return this;
  //  }
   //
  //  public addEditor(rug: Editor) {
  //    this.rugs.push(rug)
  //    return this;
  //  }
   //
  //  public addGenerator(rug: Generator) {
  //    this.rugs.push(rug)
  //    return this;
  //  }
}

class Message {
  text: string;
  channelId: string;
  regarding: TreeNode;

  private rugs: Rug[] = []

  constructor(node: TreeNode){
    this.regarding = node
  }

  public addExecutor(rug: Executor) {
    this.rugs.push(rug)
    return this;
  }

  public addEditor(rug: Editor) {
    this.rugs.push(rug)
    return this;
  }

  public addGenerator(rug: Generator) {
    this.rugs.push(rug)
    return this;
  }
}

export {Handler, Event, ExecutionPlan, Message}

//specific stuff
export let ClosedIssues: PathExpression = {
  expression: "/issue[.state()='closed']"
}

abstract class IssueRug extends Executor {
  abstract name: string
  abstract label?: string
  params: {} = {}
  constructor(){
    super();
  }
  withNumber(num: number): IssueRug {
    this.params["number"] = num
    return this
  }

  withOwner(owner: string) : IssueRug {
    this.params["owner"] = owner;
    return this;
  }
  withRepo(repo: string) : IssueRug {
    this.params["repo"] = repo;
    return this;
  }
}

export class ReopenIssue extends IssueRug {
  name = "ReopenIssue"
  constructor(readonly label: string){
    super()
  }
}

export class AssignIssue extends IssueRug {
  name = "AssignIssue"
  constructor(readonly label: string){
    super()
  }
}

export interface Issue{
  number(): number
  repo(): string
  owner(): string
}

// export let simpleHandler: Handler = {
//   name: "ClosedIssueReopener",
//   expression: ClosedIssues,
//   description: "Reopens closed issues",
//   handle(event: Event<Issue>){
//     console.log("Blady blah")
//     let issue = event.child
//
//     return new ExecutionPlan()
//       .addMessage(new Message(issue)
//         .addExecutor(new ReopenIssue("Reopen")
//           .withNumber(issue.number)
//           .withRepo(issue.repo)
//           .withOwner(issue.owner)))
//   }
// }
